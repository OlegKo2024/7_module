print('Лекция. Введение. Строки байты и кодировки')
"""
Существует некая таблица, которая называется «ASCII». Это таблица, в которой содержатся символы, и есть определённая 
связь у каждого символа и у определённого числа. Она содержит в себе символы от 0 до 127

Если мы попробуем взять отдельный символ для того, чтобы вывести число для определённого символа, мы с вами можем 
воспользоваться такой функцией встроенной, которая называется «ord - print(ord('X'))"""

chars = []
for i in 'Hello':
    chars.append(ord(i))
print(chars)                    # [72, 101, 108, 108, 111]

chars = []
for i in 'Oleg':
    chars.append(ord(i))
print(chars)                    # [79, 108, 101, 103]

chars = [79, 108, 101, 103]
word = ''
for i in chars:
    word += chr(i)
print(word)                     # Oleg

# for i in range(128):
#     print(chr(i))

"""
Но Python больше придерживается таблицы «Unicode». Она очень похожа на «ASCII», однако содержит в себе более 2000000 
символов. То есть, если «ASCII» содержит в себе только лишь 127, точнее, 128 получается у нас, то «Unicode» содержит гораздо 
больше символов. Но принцип работы точно такой же: есть определённое значение, которое связано с определённым символом.

Однако на уровне интерпретатора компьютеру проще это понимать, если он работает с байтами.
Байты-это представление строкового какого-то символа или строки целиком в двоичном или шестнадцатеричном представлении. 
Для этого существует даже отдельный тип данных для работы с байтами. И байты у нас выглядят как обычная строка, однако 
с префиксом «b» перед строкой. После префикса может быть что угодно.
"""

print(hex(ord('O')))        # \x4f
bb = b'\x4f'
print(type(bb))             # <class 'bytes'>
print(bb.decode())          # O

print('Режимы открытия файлов')

"""
Иметь файл
Импортировать пакет Python функцию «pprint» - 'from pprint import pprint'
    Эта функция «pprint» позволяет нам делать вывод в терминал более человечным или более удобно читаемым. 
    Это особенно видно, когда вы работаете с многоуровневыми структурами данных. Воспользуемся этим для работы с файлом.
Создать переменную с именем файла, например, name = 'sample.txt'
Открыть файл с функцией open и в параметрах задать режим, для этого:
    Создать переменную, куда помещаем результат работы функции. например, file
    В переменной воспользуемся функцией «open», куда передаётся имя файла и ещё перечень параметров (r, w, a)
    file = open(sample, 'r')
Воспользоваться «read» методом, для считывания файла - pprint.file.read() Запустили, увидели текст
Cчитали содержимое, закрыть файл - file.close()
Итого для чтения:
- from pprint import pprint
- name = 'sample.txt'
- file = open(name, 'r')
- pprint(file.read())
- file.close()

Для записи:
Для того чтобы записать файл, нам нужно использовать другой режим: не чтение, а запись, то есть «w». 
И здесь есть несколько нюансов: когда мы открываем файл для записи, то есть используя «w» как режим открытия, 
у нас при каждом запуске программы файл будет полностью перезаписываться. То есть текст, который мы захотим записать, 
встанет вместо текста, который был в этом файле ранее. И это не есть хорошо. Мы бы не хотели потерять содержимое этого 
файла, поэтому мы просто изменим название. 
- name = 'sample01.txt'
- file = open(name, 'w')
когда мы используем режим записи, если интерпретатор не найдёт файл с похожим названием, он просто создаст новый. 
По факту мы создадим файл «sample01.txt
Для записи:
- нам нужно использовать метод «write» 
- и потом закрыть файл
- file.write('xxxxx')
- file.close()
Запускаем, процесс выполнен. Видим то, что появился «sample01.txt» и текст «xxxxx».
Изменим, напишем просто «hello», запустим. И зайдем снова в «sample2.txt».
Текст изменился - файл перезаписывается с каждым запуском программы.
Итого для записи:
- name = 'sample01.txt'
- file = open(name, 'w')
- file.write('xxxxx')
- file.close()

Для добавления:
Чтобы добавить текст к уже существующему тексту, нам нужен третий режим. Это «append». 
Мы точно также можем воспользоваться методом «write». Однако результат работы данного метода в случае с режимом «append» 
он не будет перезаписывать файл, а просто добавлять к существующему тексту новый. Запишем «world»
Чтобы файл не слипся добавим символы переноса на новую строку '\nworld'
Запустим, появился «hello world» 
Итого для добавления:
- name = 'sample01.txt'
- file = open(name, 'a')
- file.write('xxxxx')
- file.close()
По основным режимам - их 3. Однако их гораздо больше. Если обратиться к документации, 
посмотреть на функцию «open», можно увидеть гораздо больше режимов.

Если файл является бинарным, такие файлы тоже бывают, в основном легко просто добавить буковку «b». 
Например, «ab», «rb», «wb» и так далее.

Невидимый курсор
когда мы открываем файл, у нас появляется некий невидимый курсор. 
Продемонстрируем, откроем в режиме чтения и воспользуемся «file.read» для того, чтобы считать содержимое.

Давайте выведем для нашего файла этот курсор. Метод «tell» возвращает нам положение курсора в нашем файле. 
- name = 'sample.txt'
- file = open(sample, 'r')
- print(file.tell())
- pprint.file.read()
- file.close()
Курсор находится в самом начале нашего файла, после чтения в конце.
Если нам необходимо вносить изменения в какие-то кусочки кода, нам нужно насильно передвинуть этот курсор «своими руками». 
Чтобы это сделать вместо «tell» (мы уже убедились, воспользуемся методом «seek»:
- print(file.seek(x))

"""
