print('Лекция. Введение. Строки байты и кодировки')
"""
Существует некая таблица, которая называется «ASCII». Это таблица, в которой содержатся символы, и есть определённая 
связь у каждого символа и у определённого числа. Она содержит в себе символы от 0 до 127

Если мы попробуем взять отдельный символ для того, чтобы вывести число для определённого символа, мы с вами можем 
воспользоваться такой функцией встроенной, которая называется «ord - print(ord('X'))"""

print('Coding')

chars = []
for i in 'Hello':
    chars.append(ord(i))
print(chars)                    # [72, 101, 108, 108, 111]

chars = []
for i in 'Oleg':
    chars.append(ord(i))
print(chars)                    # [79, 108, 101, 103]

chars = [79, 108, 101, 103]
word = ''
for i in chars:
    word += chr(i)
print(word)                     # Oleg


'''
Но Python больше придерживается таблицы «Unicode». Она очень похожа на «ASCII», однако содержит в себе более 2 млн.
символов. То есть, если «ASCII» содержит в себе только лишь 128, то «Unicode» содержит гораздо больше символов. 
Но принцип работы точно такой же: есть определённое значение, которое связано с определённым символом.

Однако на уровне интерпретатора компьютеру проще это понимать, если он работает с байтами.
Байты-это представление строкового какого-то символа или строки целиком в двоичном или шестнадцатеричном представлении. 
Для этого существует даже отдельный тип данных для работы с байтами. И байты у нас выглядят как обычная строка, однако 
с префиксом «b» перед строкой. После префикса может быть что угодно.

В компьютерах информация представляется в виде двоичных данных (0 и 1). Чтобы компьютер мог обработать текст и символы, 
они сначала кодируются в числовые значения с помощью определенных кодировок, таких как ASCII или UTF-8.
UTF-8 — это метод кодирования, который реализует стандарт Unicode, позволяя представлять символы Unicode в виде 
последовательностей байтов, которые могут быть обработаны компьютерами и переданы по сети

Давайте переведём с помощью функции «hex», воспользуемся ещё функцией «ord», то есть, чтобы перевести из символа «h» 
его в числовое представление и это представление мы с вами переведём в шестнадцатеричный формат

Функция `ord()` в Python возвращает кодовую точку символа в стандартной кодировке Unicode. В случае символа `'h'`, 
вызов `ord('h')` вернет 104, что соответствует кодовой точке в Unicode.
Однако важно отметить, что в таблице ASCII символ `'h'` также имеет код 104, так как ASCII является подмножеством 
Unicode для первых 128 кодов (от 0 до 127). Таким образом, значения, которые вы видите в `ord('h')`, относятся как к 
таблице Unicode, так и к ASCII, поскольку в этом диапазоне они совпадают
'''
print(ord('h'))             # 104 в кодировке Unicode
print(hex(104))             # \x4f в шестнадцатеричном формате
print(hex(ord('h')))        # \x4f
# Байты у нас выглядят как обычная строка, однако с префиксом «b» перед строкой
bb = b'\x4f'
print(type(bb))             # <class 'bytes'>
print(bb.decode())          # O

print('Режимы открытия файлов')
'''
Иметь файл
Импортировать пакет Python функцию «pprint» - 'from pprint import pprint'
    Эта функция «pprint» позволяет нам делать вывод в терминал более человечным или более удобно читаемым. 
    Это особенно видно, когда вы работаете с многоуровневыми структурами данных. Воспользуемся этим для работы с файлом.
Создать переменную с именем файла, например, name = 'sample.txt'
Открыть файл с функцией open и в параметрах задать режим, для этого:
    Создать переменную, куда помещаем результат работы функции. например, file
    В переменной воспользуемся функцией «open», куда передаётся имя файла и ещё перечень параметров (r, w, a)
    file = open(sample, 'r')
Воспользоваться «read» методом, для считывания файла - pprint.file.read() Запустили, увидели текст
Cчитали содержимое, закрыть файл - file.close()
'''
print('Итого для чтения:')

from pprint import pprint
name = 'products.txt'
file = open(name, 'r')
# pprint(file.read()) # показывает почему-то в сроке
# file.read()         # ничего не выводит в консоль
print(file.read())    # выводит содержимое в строках
file.close()

print('Для записи:')
'''
Для того чтобы записать файл, нам нужно использовать другой режим: не чтение, а запись, то есть «w». 
И здесь есть несколько нюансов: 
- когда мы открываем файл для записи, то есть используя «w» как режим открытия, у нас при каждом запуске программы 
файл будет полностью перезаписываться. То есть текст, который мы захотим записать, встанет вместо текста, который был
в этом файле ранее. И это не есть хорошо. Мы бы не хотели потерять содержимое этого файла
- поэтому мы просто изменим название. Когда мы используем режим записи, если интерпретатор не найдёт файл с похожим 
названием, он просто создаст новый. По факту мы создадим файл «sample01.txt
'''
name = 'products_00.txt'
file = open(name, 'w')
file.write('Hello')
# file.read()             # файл, открытый в режиме записи, нельзя прочесть
file.close()
'''
Запускаем, процесс выполнен. Видим то, что появился «sample01.txt» и текст «xxxxx».
Изменим, напишем просто «hello», запустим. И зайдем снова в «sample2.txt».
Текст изменился - файл перезаписывается с каждым запуском программы.
'''
print('Для добавления:')
'''
Чтобы добавить текст к уже существующему тексту, нам нужен третий режим. Это «append». 
Мы точно также можем воспользоваться методом «write». Однако результат работы данного метода в случае с режимом «append» 
он не будет перезаписывать файл, а просто добавлять к существующему тексту новый. Запишем «world»
Чтобы файл не слипся добавим символы переноса на новую строку '\nworld'
Запустим, появился «hello world» 
'''
name = 'products_00.txt'
file = open(name, 'a')
file.write('\nWorld')
# Hello
# World
file.close()

'''
По основным режимам - их 3. Однако их гораздо больше. Если обратиться к документации, 
посмотреть на функцию «open», можно увидеть гораздо больше режимов.

Если файл является бинарным, такие файлы тоже бывают, в основном легко просто добавить буковку «b». 
Например, «ab», «rb», «wb» и так далее.
'''
print('Невидимый курсор')
'''
когда мы открываем файл, у нас появляется некий невидимый курсор. 
Продемонстрируем, откроем в режиме чтения и воспользуемся «file.read» для того, чтобы считать содержимое.

Давайте выведем для нашего файла этот курсор. Метод «tell» возвращает нам положение курсора в нашем файле. 
'''
name = 'products.txt'
file = open(name, 'r')
print(file.tell())          # 0
pprint(file.read())
print(file.tell())          # 78
print(file.seek(37))        # устанавливая курсор мы можем контролировать куда будем вносить изменения
pprint(file.read())         # '3.4, Groceries\nPotato, 5.5, Vegetables\n'
file.close()
'''
Курсор находится в самом начале нашего файла, после чтения в конце.
Если нам необходимо вносить изменения в какие-то кусочки кода, нам нужно насильно передвинуть этот курсор «своими руками». 
Чтобы это сделать вместо «tell» (мы уже убедились, воспользуемся методом «seek»:
- print(file.seek(x))
'''
